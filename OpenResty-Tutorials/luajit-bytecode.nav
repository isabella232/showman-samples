# Copyright (C) by OpenResty Inc. All rights reserved
#
# The generated video is here: https://youtu.be/EP7c0BM2yNo

term:
    Hi, I'm Matthew from OpenResty Inc. Today I'd demonstrate how to pre-compile Lua modules into LuaJIT bytecode. This can help reduce the startup time of an OpenResty application.

        [delay=0] $ export PATH=/usr/local/openresty/bin:$PATH
        $ cd ~
        $ mkdir -p precomp
        $ cd precomp/

    Here we will use a big Lua module file named `pkg-stap.lua`. It was generated by our `opslang` compiler.

        $ cp ~/git/opslang/pkg-stap.lua ./
        $ ls -lh *.lua

    [S] We can see that this Lua module is 1.6 mega bytes.

    Let's try loading this Lua module with the `resty` utility.

        $ time resty -I. -e 'require "pkg-stap"'

    [S] It takes 23 milliseconds in total.

    Let's check the original overhead of running an empty Lua program.

        $ time resty -e ''

    [S] It is about 11 milliseconds. So loading the module itself takes about 12 milliseconds.

    Let's try precompiling the Lua module into LuaJIT bytecode.

        $ time /usr/local/openresty/luajit/bin/luajit -bg pkg-stap.lua pkg-stap.ljbc

    [S] Here we use OpenResty's `luajit` program.

    It generates a LuaJIT bytecode file with the `.ljbc` file extension.

        $ ls -lh *.ljbc

    [S] It's fun to see the bytecode file is also more than 50% smaller!

    Then try loading it with `resty` again.

        $ time resty -I. -e 'require "pkg-stap"'

    [S] Just 13 milliseconds in total!

    It's now almost like loading an empty Lua program! Only about 2 milliseconds extra.

        $ time resty -e ''

    [S] The `resty` utility always tries to load an `.ljbc` file before a `.lua` file when loading a module.

    Let's see how to make it work for an OpenResty server.

        $ mkdir conf logs lua

    Copy our Lua module files to the `lua/` subdirectory.

        $ mv *.lua *.ljbc lua/
        $ tree .

    Write a simple nginx configuration file.

        vim conf/nginx.conf
        i[NONL]

    Use a single nginx worker process.

        worker_processes 1;
        [NOP]

    Use 1024 worker connections.

        events {
        worker_connections 1024;
        }
        [NOP]
        http {

    Here it is important to try `.ljbc` files before `.lua` files.

        lua_package_path "$prefix/lua/?.ljbc;$prefix/lua/?.lua;;";

    [S] You can also try keeping the `.ljbc` files only to be sure.

    We preload our modules so that any module loading failures can be caught upon server startup.

        [NOP]
        init_by_lua_block {
        require "pkg-stap"
        }

    This also leads to faster first requests, and smaller memory footprint due to the `COW` optimization.

        [NOP]
        server {
        listen 8080;
        location / { return 200 "ok\n"; }
        }
        }

    Save the file and quit vim.

        [ESC][NONL]
        :wq[NONL]
        [SLEEP=1][NOP]
        $

    Check the directory tree.

        $ tree .

    [S] Looking good!

    Try testing the server configuration using the `-t` option.

        $ time openresty -p $PWD/ -t

    Start it up.

        [UP][NONL]
        [BS][BS][BS][NONL]
        [SLEEP=0.3][NOP]
        $

    [S] About 7 milliseconds.

    Try removing the LuaJIT bytecode file.

        $ rm lua/*.ljbc

    Stop the server.

        $ kill -QUIT `cat logs/nginx.pid`

    Start the server again.

        $ time openresty -p $PWD/

    [S] This time it is 17 milliseconds! We can see it is 10 milliseconds slower too by loading the Lua source file.

    Finally, try removing the Lua source files too.

        $ rm lua/*.lua

    Stop the server and start it again.

        [SLEEP=0.3][UP][NONL]
        [SLEEP=0.3][UP][NONL]
        [SLEEP=0.3][UP][NONL]
        [SLEEP=0.4][NOP]
        time openresty -p $PWD/ |& less[NONL]
        [SLEEP=1][NOP]
        [SLEEP=2][SP][NONL]

    [S] This time, we get an error as expected since both versions of the module are gone.

    For small Lua module files, it is already very fast to load their source code.

        q[NONL]
        $

        $ echo 'local _M = {} function _M.foo() end return _M' > a.lua
        $ ls -l a.lua
        $ time resty -I. -e 'require "a"'

    Precompiling a small Lua module file won't help much.

        $ time /usr/local/openresty/luajit/bin/luajit -bg a.lua a.ljbc
        $ time resty -I. -e 'require "a"'

    [S] Indeed not much. But the time saving can accumulate quickly if you have many small modules to load up.
